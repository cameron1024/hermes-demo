# hermes demo

This is an example module for hermes. 
If you care about this, you probably already know where to find the hermes binary.
Just make sure it's on $PATH.

## Quick end-user guide

You may want to install shell completions.
Exact instructions vary per shell, but for me, `hermes completions fish | source` does it.
Should be relatively obvious

Hermes is configured via a `hermes.toml` file in your current dir. 
It works without any config, but won't run any WASM in this mode.
You can see the "default config" by running `hermes gen-config`
This will write the default config to `./hermes.toml` (if it doens't exist).

Anything picked up in your `hermes.toml` will override anything in this default file.
So it's totally fine to have a blank `hermes.toml`, it's no different to just using the default.

### This repo's `hermes.toml`

This repo's `hermes.toml` is pretty simple:
```toml
[consumers."hello-cardano"]
wasm-path = "./component.wasm"
```
The term "consumer" is from a previous design for hermes, but you can think of a "consumer" as just another word for "WASM module" (i'm just going to call them "modules" from now on).
The only required argument for a module is a path to the WASM binary.
On startup, Hermes will load all the listed modules, and dispatch events to them as they come in.

In the future, we'd expect that you'd be able to write:
```toml
[consumers."hello-cardano"]
wasm-path = "./component.wasm"
capture-stdout = "/tmp/hermes-hello-cardano.log"
capabilities = [
    "http.get",
    "http.post",
    "pubsub.pub",
]
allowed-hosts = [
    "iohk.io",
    "google.com",
    "*.example.com",
]
allowed-pubsub-channels = [ "my-important-pubsub-channel" ]
```
This is just a rough idea, and hasn't gone through much design work.
You can think of this a bit like an app manifest (comparable to the kind you'd get on Android for example).

### Running it

You run hermes with `hermes run` (creative, I know üòú).
This (currently) requires a few things:
 - `mongod` on the path (nix users can get it from the flake inside the hermes repo)
 - `ipfs daemon --enable-pubsub-experiment` running in another shell

These are temporary limitations, and we don't plan on keeping them (especially not given the deployment targets we have in mind).
Honestly, we only finished building the PoC for the demo like 40 minutes before the meeting üòÖ

I'd also recommend setting `RUST_LOG=info` to see more of the logs.

### So how do I make my own module?

It's really easy :) .
The `component` directory contains the code, so if you just wanna get up and running ASAP, just adapt that.
If you want to understand the process a bit more, here it is:
 - make sure you're set up to build Rust code. If you're new to Rust, install `rustup` via your system package manager, and install the latest version. And if you want a painless dev environment, just use VSCode with the rust-analyzer plugin
 - make sure you have `wasm32-unknown-unknown` installed via `rustup target add wasm32-unknown-unknown`
 - make a new Rust library with `cargo new --lib my-cool-library` and delete all the stuff in `lib.rs`
 - copy the WIT file into `<project-root?/wit/hermes.wit`
 - make the following changes to `Cargo.toml`:
   - set the crate type to `cdylib` with:
```toml
[lib]
crate-type = ["cdylib"]
```
   - add `wit-bindgen` as a dependency with:
```toml
[dependencies]
wit-bindgen = "0.6"
```
 - use `wit-bindgen` to GENerate BINDings for the Hermes API defined in the WIT file
```rust
wit_bindgen::generate!("hermes");
```
 - Now we create a struct and export it:
```rust
wit_bindgen::generate!("hermes");

struct Host;
export_hermes!(Host);
```
This will cause an "unsatisfied trait error".
For those not familiar with Rust, a "trait" is a bit like an interface.
It provides the signatures of methods, but not the implementation.
If we want `Host` to implement the right trait, we need to add the implementation:
```rust
wit_bindgen::generate!("hermes");

struct Host;
export_hermes!(Host);

// `Hermes` is a trait generated by `wit_bindgen::generate!`
impl Hermes for Host {
    fn on_new_cardano(block: CardanoBlock) {
        todo!()
    }

    fn on_new_ethereum(rpc: wit_bindgen::rt::string::String) {
        todo!()
    }
}
```
This is where the actual logic goes.

Note, you'll have access to `tweet`, `publish`, `blake_hash`, since these are functions provided by the host (i.e. Hermes).
You can call these functions, and it will get use the implementations provided by Hermes.

There's no fundamental reason why `blake_hash` couldn't be implemented *inside* the WASM module - you can add dependencies like you would for any normal Rust app.
But we've provided this to show how "common functions" could be brought into Hermes (a bit like the stdlib of your favourite programming language), to:
 - make it run faster - WASM is very fast, but Rust is generally faster, especially for things like cryptographic primatives
 - save WASM space - if we want WASM code to exist in space constrained environments (e.g. on-chain), it would be nice if they didn't all need blake impls bloating the binary
 - save compilation time for WASM modules - we're very invested in the developer experience of module authors, and shaving some compile time is always nice

### Building

The `build.sh` file in this repo shows how to build the module. 
There's only really 2 steps:
 - Rust -> WASM (with `cargo`)
 - WASM -> WASM component-model (with `wasm-tools`)

Step 1 is as simple as running `cargo build --release --target wasm32-unknown-unknown`.

Step 2 is also pretty simple:
 - make sure you have `wasm-tools` installed
 - `wasm-tools component new <project-root>/target/wasm32-unknown-unknown/release/<project-name>.wasm -o component.wasm`

This will make a file called `component.wasm` that you can then load into Hermes as shown earlier by specifying in `hermes.toml`

Feel free to ping me in slack if you have any more questions.
I'm aware there's a lot of new stuff, happy to explain if anything's not clear üòÅ





